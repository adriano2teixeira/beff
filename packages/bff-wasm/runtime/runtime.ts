import { ClientFromRouter } from "./client";
import { DecodeError, DecodeErrorKind, HandlerMeta } from "./types";

export const template = `
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta
      name="description"
      content="SwaggerUI"
    />
    <title>SwaggerUI</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css" />
    <link rel="stylesheet" href="https://unpkg.com/swagger-ui-dist@5.0.0/swagger-ui.css" />

  </head>
  <body>
  <div id="swagger-ui"></div>
  <script src="https://unpkg.com/swagger-ui-dist@5.0.0/swagger-ui-bundle.js" crossorigin></script>
  <script src="https://unpkg.com/swagger-ui-dist@5.0.0/swagger-ui-standalone-preset.js" crossorigin></script>
  <script>
    window.onload = () => {
      window.ui = SwaggerUIBundle({
        url: '/api/v3/openapi.json',
        dom_id: '#swagger-ui',
        presets: [
          SwaggerUIBundle.presets.apis,
          SwaggerUIStandalonePreset
        ],
        layout: "StandaloneLayout",
      });
    };
  </script>
  </body>
</html>
`;

const printKind = (kind: DecodeErrorKind): string => {
  switch (kind[0]) {
    case "NotTypeof": {
      return `expected ${kind[1]}`;
    }
    default: {
      return "unknown";
    }
  }
};
const printValidationErrors = (errors: DecodeError[]): string => {
  return errors
    .map((e) => {
      return `Decoder error at ${e.path.join(".")}: ${printKind(e.kind)}.`;
    })
    .join("\n");
};

export class BffHTTPException {
  public status: number;
  public message: string;
  constructor(status: number, message: string) {
    this.status = status;
    this.message = message;
  }
}

export const decodeWithMessage = (validator: any, value: any): any => {
  const errs = validator(value);
  if (errs.length > 0) {
    throw new BffHTTPException(422, printValidationErrors(errs));
  }
  return value;
};
export const decodeNoMessage = (validator: any, value: any): any => {
  const errs = validator(value);
  if (errs.length > 0) {
    throw new BffHTTPException(422, "Internal validation error");
  }
  return value;
};
export const coerce = (coercer: any, value: any): any => {
  return coercer(value);
};

declare const meta: any;

// This file is generated by swc-bff
// Do not edit this file manually
type Decoder<T> = { parse: (value: unknown) => T };
type DecodersOfKV<T> = {
  [K in keyof T]: Decoder<T[K]>;
};
export declare const buildDecoders: <T>() => DecodersOfKV<T>;

export type Header<T> = T;
export type Cookie<T> = T;

export const todo = <T>(): T => {
  throw new Error("TODO: not implemented");
};

export class BffRequest {
  public method: "GET" | "POST" | "PUT" | "DELETE" | "PATCH" | "OPTIONS";
  public url: string;
  public headers: Record<string, string>;
  public cookies: string[];
  public requestBodyStringified?: string;
  constructor(
    method: "GET" | "POST" | "PUT" | "DELETE" | "PATCH" | "OPTIONS",
    url: string,
    headers: Record<string, string>,
    cookies: string[],
    requestBodyStringified?: string
  ) {
    this.method = method.toUpperCase() as any;
    this.url = url;
    this.headers = headers;
    this.cookies = cookies;
    this.requestBodyStringified = requestBodyStringified;
  }
}

export function buildStableClient<T>(
  fetcher: (url: BffRequest) => Promise<any>
): ClientFromRouter<T> {
  const client: any = {};
  const handlersMeta: HandlerMeta[] = meta["handlersMeta"];
  for (const meta of handlersMeta) {
    if (client[meta.pattern] == null) {
      client[meta.pattern] = {};
    }

    client[meta.pattern][meta.method_kind] = async (...params: any) => {
      let url = meta.pattern;
      const method = meta.method_kind.toUpperCase() as any;
      const init: Partial<BffRequest> = {};
      init.headers = {};
      init.headers["content-type"] = "application/json";
      let hasAddedQueryParams = false;

      const clientParams = meta.params.filter((it) => it.type != "context");

      for (let index = 0; index < clientParams.length; index++) {
        const metadata = clientParams[index];
        const param = params[index];
        switch (metadata.type) {
          case "path": {
            url = url.replace(`{${metadata.name}}`, param);
            break;
          }
          case "query": {
            if (!hasAddedQueryParams) {
              url += "?";
              hasAddedQueryParams = true;
            }
            url += `${metadata.name}=${param}&`;
            break;
          }
          case "header": {
            init.headers[metadata.name] = param;
            break;
          }
          case "cookie": {
            if (init.cookies == null) {
              init.cookies = [];
            }
            init.cookies.push(`${metadata.name}=${param}`);
            break;
          }
          case "body": {
            init.requestBodyStringified = JSON.stringify(param);
            break;
          }
          case "context": {
            // not a client parameter
            break;
          }
          default: {
            throw new Error("not implemented: " + metadata.type);
          }
        }
      }

      return await fetcher(
        new BffRequest(
          method,
          url,
          init.headers ?? {},
          init.cookies ?? [],
          init.requestBodyStringified
        )
      );
    };
  }
  return client;
}
